用于记录刷面试题时，碰见的笔试难题

## 矩阵快速幂

二分幂、快速幂、矩阵快速幂在算大指数次方时是很高效的。

> 求 a^n 的值是多少？n是1到$10^{18}$次方的一个整数。 
>
> 求一个数的n次方，朴素的算法就是直接for循环，一遍一遍的乘，$a*a*a*a*a*a…$，O(N)的复杂度。此时，如果n很小的话，并没有什么影响。

 但是当n非常大，O(N)就会超时，那么需要更快的算法，比如，**二分幂算法和快速幂算法**。

### 二分幂

要求 a^n，如果知道了 a^(n/2) 次方的话，再来个平方就可以了。 即 

> 如果n是偶数，则$A=a^{n/2} ；  A=A*A$。 
> 如果n是奇数 , 则$A=a^{(n-1)/2}； A=a*A*A$。 

这就一下子差不多就节省了$n/2-1$次乘法运算 

那么按照这个思路就能运用分治的思想,那么复杂度就有原来的O(n)，降低为O(lgn)。

```c++
long long int pow(int a,int n) // 求a的n次幂
{
    if (n==0)
        return 1;
    if (n==1)
        return a;
    long long int ans = pow(a,n/2); // 从函数的功能区理解递归
    ans *= ans;
    if ( n%2==1 )
        ans*=a;
    return ans;
}
```

### 快速幂

快速幂，在算大指数次方时是很高效的。他的基本原理是**二进制**。

大家首先要认识到这一点：任何一个整数N，都能用二进制来表示。 

比如$a^{156}$，而$156(10) = 10011100(2) 。$

那么 
$$
A=a^{156}=a^{10011100} \\
=a^{2^7∗1+2^6∗0+2^5∗0+2^4∗1+2^3∗1+2^2∗1+2^1∗0+2^0∗0} \\
=(a^{2^7∗1})*(a^{2^6∗0})*(a^{2^5∗0})*(a^{2^4∗1})*(a^{2^3∗1})*(a^{2^2∗1})*(a^{2^1∗0})*(a^{2^0∗0}) \text {，*0项结果为1}
$$
我们就按照这个公式来求解$a^{156}$，原来要进行$156-1=155$次乘法运算，现在运算次数就是**二进制的长度*二进制中1的个数**，即$8*4 = 24$。

```c++
long long int fun( int a, int b ) 
{
    long long int r = 1;
    int base = a;
    while( b != 0 ) 
    {
        if(b & 1)//判断奇偶性
        {
            r *= base;
        }
        base *= base; //注意：a^{2^7} = a^{2^6} * a^{2^6}
        b >>= 1;
    }
    return r;
}
```

### 矩阵快速幂

可能你会问，上述算法有什么用？其实用的更多的是利用**矩阵快速幂**求递归式。例如，$f(n) = a * f(n - 1) + b * f(n-2)$。简单来说，求斐波拉切数列的第一亿项的结果模上10000000后是多少？此时，逐步递推显然不合理呢。

对于$f(n) = a * f(n - 1) + b * f(n-2)$，我们可以构造矩阵，
$$
\begin{pmatrix} a & b \\ 1 & 0 \\ \end{pmatrix} 
\begin{pmatrix} f(n-1) \\ f(n-2)  \end{pmatrix}
=
\begin{pmatrix} f(n) \\ f(n-1)  \end{pmatrix}
$$
即，
$$
\begin{pmatrix} f(n) \\ f(n-1)  \end{pmatrix} = 
\begin{pmatrix} a & b \\ 1 & 0 \\ \end{pmatrix}^{n-2}
\begin{pmatrix} f(2) \\ f(1)  \end{pmatrix}
$$
这样求$f(n), f(n-1)$就相当于求左边距的n-2次幂。这个时候，就可以用上述快速幂来计算了。代码与快速幂类似，只是实数乘法变成了矩阵乘法。

### 快速乘

求$(a * b )\% m$ , 当a*b结果很大，乘完后可能会超出范围。 

可以利用二进制来实现快速乘算法。

以前十进制的乘法是： $123*567=123*5*100 + 123*6*10 + 123 * 7 * 1$

如果考虑二进制的话，我们任选其他任意二进制数，就有 ,
$$
1001101∗11010=\\1001101∗2^4∗1+1001101∗2^3∗1+1001101∗2^2∗0+1001101∗2^1∗1+1001101∗2^0∗0
$$
我们对上面的每一个加项进行取模，在加起来，就不会溢出了。

```c++
long long int fun(long long int a ,long long int b , long long int m)
{
    int sum=0;
    int k=1;
    while(b)
    {

        if(b&1)
        {
            sum=(sum+a*k)%m;
        }
        k = ( k*2 ) % m;
        b = (b >> 2);
    }
}
```

我们在做很多”连续“的问题的时候都会用到二进制将他们离散简化 

1. 多重背包问题 

2. 树状数组 

3. 状态压缩DP 

……………还有很多。。。究其根本还是那句话：**化连续为离散**。很多时候我们并不是为了解决一个问题而使用二进制，更多是时候是为了优化而使用它。所以如果你想让你的程序更加能适应大数据的情况，那么学习二进制及其算法思想将会对你有很大帮助。

[二分幂，快速幂，矩阵快速幂，快速乘](https://blog.csdn.net/MosBest/article/details/69264953)

[从快速幂到 dp 优化：矩阵快速幂](https://www.zybuluo.com/Dmaxiya/note/1015379)

